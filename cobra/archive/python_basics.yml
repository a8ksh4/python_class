# A label identifies the question unique to the .yml lesson
dictionaries_2:
    # This is an example question
    # It shows off the format used
    text: |
        Put the following items into a prices dictionary and return it:
        "bananna": 4,
        "apple": 2,
        "orange": 1.5,
        "pear": 3
        
        def myPricesDict():
           #your code here
           return my_prices
           
    signature: "myPricesDict() -> dict"
    # I'm putting this in base64, I think it might help readability. This codes to:
    # def add(num_1, num_2):
    #     return num_1 + num_2
    solution: !!binary "ZGVmIG15UHJpY2VzRGljdCgpOgogICAgbXlfcHJpY2VzID0geyJiYW5hbm5hIjogNCwgImFwcGxlIjogMiwgIiBvcmFuZ2UiOiAxLjUsICJwZWFyIjogM30KICAgIHJldHVybiBteV9wcmljZXM="
    # order to serve questions. Same tier served randomly
    tier: 1
    unittests: ~
    # Used for any outside module dependancies
    imports: ""
    # Setup scripts to prep an environment. Run before unittests
    setup: ""
    # Teardown scripts to clean up the environment. Run after unittests
    teardown: ""
    # Scripts to be run before individual tests take place    
    pretest: ""
    # Scripts to be run after infividual tests take place
    posttest: ""
    # Tags can be used to sort and filter questions
    tags:
        - basics
        - dictionart
    # This is how many times the challenge has been solved
    successes: 0
    # These are derived from user ratings, the data can be used as question feedback
    # think of them like upvotes/downvotes, but more category specific
    ratings:
        challenging: 0
        useful: 0
        interesting: 0
    # The solution history, every success can be stored here.
    history: ~