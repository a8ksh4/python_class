basic_math_1:
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  setup: seed({seed})
  signature: addThem(int, int) -> int
  solution: "def addThem(num_a, num_b):\n    return num_a + num_b\n"
  tags: ''
  teardown: 'open(''/tmp/teardown'',''w'').write(str(dir()))

    '
  text: "Write a function that takes 2 integers as parameter\nIt should return the\
    \ sum of the 2 integers.\n\nE.g. \ndef addThem(num_a, num_b):\n    #your code\
    \ here\n    return the_sum\n"
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(-3)
    - int(0)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
basic_math_2:
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  setup: seed({seed})
  signature: remainder(int, int) -> int
  solution: "def remainder(a, b):\n    the_remainder = a%b\n    return the_remainder\n"
  tags: ''
  teardown: ''
  text: "Write a function that takes 2 integers as parameters and returns the remainder\n\
    from dividing the first number, \"a\", into the second number, \"b\". \n\nE.g:\n\
    def remainder(a, b):\n    #your code here\n    return the_remainder\n"
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(10)
    - int(1)
    test3:
    - randint(100,500)
    - randint(100,200)
    test4_x4:
    - randint(1000,2000)
    - randint(1,10)
basic_math_3:
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  setup: seed({seed})
  signature: toInt(float) -> int
  solution: "def toInt(a_float):\n    an_int = int(a_float)\n    return an_int\n"
  tags: ''
  teardown: ''
  text: "Write a function that takes a floating point number and returns it\nas an\
    \ integer.\n\nE.g:\ndef toInt(a_float):\n    #your code here\n    return an_int\n"
  unittests:
    test1:
    - int(7.2)
    test2:
    - int(-3.4)
    test3:
    - randint(100,1000)/randint(100,1000)
    test4_x4:
    - (randint(1000,10000) * -1) /randint(100,1000)
basic_math_4:
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  setup: seed({seed})
  signature: divideThemInt(int, int) -> (int, int)
  solution: "def divideThemInt(num_a, num_b):\n    return (num_a // num_b, num_a %\
    \ num_b)\n"
  tags: ''
  teardown: ''
  text: "Write a function that divides two integers and returns a tuple with the first\
    \ value equal to the integer diviion result, and teh second value equal to the\
    \ remainder. \n\nE.g:\ndef divideThemInt(num_a, num_b):\n    #your code here\n\
    \    return (sum_of_them, remainder)\n"
  unittests:
    test1:
    - int(7)
    - int(5)
    test2:
    - int(-3)
    - int(1)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
basic_math_5:
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  setup: seed({seed})
  signature: divideThem(int, int) -> float
  solution: "def divideThem(num_a, num_b):\n    return float(num_a) / float(num_b)\n"
  tags: ''
  teardown: ''
  text: "Write a function that divides two integers and returns a floating point result.\n\
    Note: the result should be a float even if the division has no remainder...\n\n\
    E.g:\ndef divideThem(num_a, num_b):\n    #your code here\n    return the_result\n"
  unittests:
    test1:
    - int(7)
    - int(5)
    test2:
    - int(-3)
    - int(6)
    test3:
    - randint(1,100)
    - randint(1,100)
    test4_x4:
    - randint(1,1000)
    - randint(1,5)
basic_math_6:
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  setup: seed({seed})
  signature: convertCToF(int) -> float
  solution: "def convertCToF(temp_in_c):\n    return temp_in_c/5.0 + 32.0/9.0\n"
  tags: ''
  teardown: ''
  text: "Write a function that accepts a temperature in Centigrade and returns an\n\
    equivelant temperature in Farenheight. \n\nThe equation for this is (f = c/5 +\
    \ 32/9)\n\nE.g:\ndef convertCToF(temp_in_c):\n    #your code here\n    return\
    \ temp_in_f\n"
  unittests:
    test1:
    - int(7)
    test2:
    - int(-3)
    test3:
    - randint(-100,-1)
    test4_x4:
    - randint(-1000,-1)
branching_1:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: getTruthiness(obj) -> string
  solution: "def getTruthiness(obj):\n    if obj:\n        resulting_word = \"tequilla\"\
    \n    else:\n        resulting_word = \"margarita\"\n    return resulting_word\n"
  tags: ''
  teardown: ''
  text: "Create a function called getTruthiness that is given an objct and, if\nthat\
    \ object evaluates True, returns \"tequilla\", otherwise it returns,\n\"margarita\"\
    . \n\nE.g:\ndef getTruthiness(obj):\n    #your code here\n    return resulting_word\n"
  unittests:
    test1:
    - true
    test2:
    - '""'
    test3:
    - '"a"'
    test4:
    - '"()"'
branching_2:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: twosTruthiness(bool, bool, bool, bool) -> string
  solution: "def twosTruthiness(obj0, obj1, obj2, obj3):\n    items = (obj0, obj1,\
    \ obj2, obj3)\n    count = len([o for o in items if o == True])\n    if count\
    \ == 2:\n        resulting_word = \"twos\"\n    elif count == 3:\n        resulting_word\
    \ = \"threes\"\n    else:\n        resulting_word = \"foobar\"\n    return resulting_word\n"
  tags: ''
  teardown: ''
  text: "Create a function called twosTruthiness that is given four boolean values.\n\
    if any two of the four are True, then return \"twos\".  If any three of them are\n\
    True, then return \"threes\", if less than two or four of them are True, then\n\
    return \"foobar\"\n\nE.g:\ndef twosTruthiness(obj, obj, obj, obj):\n    #your\
    \ code here\n    return resulting_word\n"
  unittests:
    test1:
    - (True, True, False, False)
    test2:
    - (False, True, False, True)
    test3:
    - (True, True, False, True)
    test4:
    - (True, True, True, True)
branching_3:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: carmenFound(dict) -> string
  solution: "def carmenFound(cities):\n    for city in cities:\n        if cities[city]\
    \ == True:\n            return city\n"
  tags: ''
  teardown: ''
  text: "Create a function called carmenFound that is given a dictionary with a list\
    \ of\ncity names as keys, each associated with a boolean value indicating whether\n\
    or not Carmen is in the city.  Return the name of the city Carmen is found in!\n\
    \nE.g:\ndef carmenFound(cities):\n    #your code here\n    return city_name\n"
  unittests:
    test1:
    - atlanta: true
      menphis: false
      redding: false
    test2:
    - atlanta: false
      menphis: true
      redding: false
dictionaries_1:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: pocketContents() -> dict
  solution: "def pocketContents():\n    inventory = {\n        'gold' : 500,\n   \
    \     'pouch' : ['flint', 'twine', 'gemstone'],\n        'backpack' : ['xylophone','dagger',\
    \ 'bedroll','bread loaf']\n    }\n    inventory['pocket'] = ['seashell']\n   \
    \ return inventory\n"
  tags: ''
  teardown: ''
  text: "Given the following dictionary called \"inventory\", modify the pocketContents\n\
    function to add a 'pocket' into the dictionary with contents 'seashell'\n(a single\
    \ string in a list).\n\nE.g:\ndef pocketContents():\n    inventory = {\n     \
    \   'gold' : 500,\n        'pouch' : ['flint', 'twine', 'gemstone'],\n       \
    \ 'backpack' : ['xylophone','dagger', 'bedroll','bread loaf']\n    }\n\n    return\
    \ inventory\n"
  unittests:
    test1:
    - '" rofl this is cool "'
    test2:
    - '" ABCDS"'
    test3:
    - '"zABCDS "'
dictionaries_2:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: myPricesDict() -> dict
  solution: "def myPricesDict():\n    my_prices = {\"bananna\": 4, \"apple\": 2, \"\
    orange\": 1.5, \"pear\": 3}\n    return my_prices\n"
  tags: ''
  teardown: ''
  text: "Put the following items into a prices dictionary and return it:\n    \"bananna\"\
    : 4,\n    \"apple\": 2,\n    \"orange\": 1.5,\n    \"pear\": 3\n\nE.g:\ndef myPricesDict():\n\
    \    #your code here\n    return my_prices\n"
  unittests:
    test1: null
dictionaries_3:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: mergeToDict(list, list) -> dict
  solution: "def mergeToDict(keys, values):\n    resulting_dict = dict(zip(keys, values))\n\
    \    return resulting_dict\n"
  tags: ''
  teardown: ''
  text: "Given a list of keys and a list of corresponding values, create a dictionary\n\
    containing them and return it as output. You may assume that both lists will\n\
    always be the same length.\n\nFor example, if the keys were ('color', 'flavor',\
    \ 'texture') and the values\nwere ('red', 'sour', and 'rough'), the dictionary\
    \ would look like:\n{'color': 'red', 'flavor': 'sour', 'texture': 'rough'}\n\n\
    E.g:\ndef mergeToDict(keys, values):\n    #your code here\n    return resulting_dict\n"
  unittests:
    test1:
    - (1, 2, 3, 4)
    - (5, 6, 7, 8)
    test2:
    - ('1', '2', '3', '4')
    - ('a', 'b', 'c', 'd')
    test3:
    - ('1', '2', '3', '4')
    - ([1,], [2,], [3,], [4,])
dictionaries_4:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: getDictKeys(dict) -> list
  solution: "def getDictKeys(a_dictionary):\n    return a_dictionary.keys()\n"
  tags: ''
  teardown: ''
  text: "Write a function called getDictKeys that is given a dictionary and returns\
    \ a \nlist of keys in the given dictionary. \n\nE.g:\ndef getDictKeys(a_dictionary):\n\
    \    # do stuff here\n    return all_the_keys\n"
  unittests:
    test1:
    - a: 1
      b: 2
      c: 3
    test2:
    - 1: 1
      c: None
      ('a': null
      ): 2
      b: {}
      a: []
dictionaries_5:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: checkKeyExists(dict, key) -> bool
  solution: "def getDictKeys(a_dictionary):\n    return a_dictionary.keys()\n"
  tags: ''
  teardown: ''
  text: "Write a function called checkKeyExists that is given a dictionary and a key\
    \ and\nreturns True if the key exists in the dictionary or False if it does not.\
    \ \n\nE.g:\ndef checkKeyExists(a_dictionary, the_key):\n    # do stuff here\n\
    \    return exists_bool\n"
  unittests:
    test1:
    - a: 1
      b: 2
    - a
    test2:
    - a: 1
      b: 2
    - 1
    test3:
    - a: 1
      b: 2
    - b
    test4:
    - a: 1
      b: 2
    - c
    test5:
    - a: 1
      b: 2
    - '2'
dictionaries_6:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: checkKeysExist(dict, keys) -> dict
  solution: "def checkKeysExists(the_dict, keys):\n    out = {}\n    for key in keys:\n\
    \        out[key] = key in the_dict\n    return out\n"
  tags: ''
  teardown: ''
  text: "Write a function called checkKeysExists that is given a dictionary and a\
    \ list\nof keys to look for in teh dictionary.  The function returns a new dictionary\n\
    containing each key in the provided list with an associated boolean value\nindicating\
    \ whether or not the key from the list was found in the given\ndictionary.\n\n\
    As an example, if given {'a': 0, 'b': 1} and ['a', 'c'] for keys, the output\n\
    would be {'a': True, 'c': False}. \n\nE.g:\ndef checkKeysExists(a_dictionary,\
    \ some_keys):\n    # do stuff here\n    return exists_dict\n"
  unittests:
    test1:
    - a: 12
      b: 2
    - - a
      - c
      - d
    test2:
    - a: 1
      b: 2
    - ()
dictionaries_7:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: printGivenKeys(dict, list)
  solution: "def checkKeysExists(the_dict, keys):\n    out = {}\n    for key in keys:\n\
    \        out[key] = key in the_dict\n    return out\n"
  tags: ''
  teardown: ''
  text: "Write a function called printGivenKeys that is given a dictionary and a list\n\
    of keys to look for in teh dictionary.  For each item in the list, the function\n\
    prints the item and the value associated with it in the provided dictionary.\n\
    If the item is not in the dictionary, None is used for the value. \n\nAs an example,\
    \ if given {'a': 0, 'b': 1} and ['a', 'c'] for keys, it would \nprint:\na, 0\n\
    c, None\n\nE.g:\ndef printGivenKeys(a_dictionary, some_keys):\n    # do stuff\
    \ here\n    # return nothing\n"
  unittests:
    test1:
    - a: 12
      b: 2
    - - a
      - c
      - d
    test2:
    - a: 1
      b: 2
    - ()
lists_1:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: sumAllItems(list of num) -> number
  solution: "def sumAllItmes(some_nums):\n    the_sum = 0\n    for num in some_nums:\n\
    \        the_sum += num\n    return the_sum\n"
  tags: ''
  teardown: ''
  text: "write a function called sumAllItems that accepts a list or tuple of numbers,\
    \ \nsumms them, and returns the sum. \n\nE.g:\ndef sumAllItmes(some_nums):\n \
    \   # do stuff here\n    return the_sum\n"
  unittests:
    test1:
    - - 1
      - 2
      - 3
      - 4
      - 5
    test2:
    - - -5
      - 2.2
      - 999
      - -1000.0
    test3:
    - - 1
      - -2
      - 4
      - -6
      - 123.1
lists_2:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: smallestOfList(list of numbers) -> number
  solution: "def smallestOfList(some_nums):\n    smallest = some_nums[0]\n    for\
    \ num in some_nums:\n        if num<smallest:\n            smallest = num\n  \
    \  return num\n"
  tags: ''
  teardown: ''
  text: "Write a function called smallestOfList that accepts a list or tuple of numbers\
    \ \nand returns the smallest number found in the list.\n\nE.g:\ndef smallestOfList(some_nums):\n\
    \    # do stuff here\n    return the_smallest\n"
  unittests:
    test1:
    - - 1
      - 2
      - 3
      - 4
      - 5
    test2:
    - - -5
      - 2.2
      - 999
      - -1000.0
    test3:
    - - 1
      - -2
      - 4
      - -6
      - 123.1
sets_1:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: convTupleUnique(list) -> tuple
  solution: "def convTupleUnique(some_items):\n    return tuple(set(some_items))\n"
  tags: ''
  teardown: ''
  text: "Write a function called convTupleUnique(list) that accepts a list of objects\n\
    and returns a tuple (not a list) with only the unique items from the list. \n\
    Order of the returned list is not important.\n\nE.g:\ndef convTupleUnique(some_items):\n\
    \    # do stuff here\n    return unique_items\n"
  unittests:
    test1:
    - asfd
    - b
    - b
    - c
    - b
    - '1'
    - '2'
    - b
    - a
sets_2:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: convTupleUniqueOrder(list) -> tuple
  solution: "def convTupleUniqueOrder(some_items):\n    out = []\n    for item in\
    \ some_items:\n        if item in out:\n            continue\n        out.append(item)\n\
    \    return tuple(out)\n"
  tags: ''
  teardown: ''
  text: "Write a function called convTupleUniqueOrder(list) that accepts a list of\n\
    objects and returns a tuple (not a list) with only the unique items from the\n\
    list. Order of the returned tuple IS important. Order from the original list\n\
    should be preserved; the first time an object is observed in the given list, \n\
    it is in the returned tuple, and subsequent occurences are ignored. \n\nE.g:\n\
    def convTupleUniqueOrder(some_items):\n    # do stuff here\n    return unique_items\n"
  unittests:
    test1:
    - asfd
    - b
    - b
    - c
    - b
    - '1'
    - '2'
    - b
    - a
sets_3:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: createSet(obj, obj, obj, obj, obj) -> set
  solution: "def createSet(obj1=None, obj2=None, obj3=None, obj4=None, obj5=None):\n\
    \    new_set = set()\n    for obj in (obj1, obj2, obj3, obj4, obj5):\n       \
    \ if obj != None:\n            new_set.add(obj)\n    return new_set\n"
  tags: ''
  teardown: ''
  text: "Write a function called createSet that accepts up to five objects, adds them\n\
    into a set, and returns a set of those objects. Hint: \"set\" is a data type.\
    \ \nDo not add any of the objects fo the set if the object is equal to the None\n\
    object.\n\nE.g:\ndef createSet(obj1=None, obj2=None, obj3=None, obj4=None, obj5=None):\n\
    \    # do stuff here\n    return new_set\n"
  unittests:
    test1:
    - asfd
    - b
    - b
    - c
    - b
    - '1'
    - '2'
    - b
    - a
sets_4:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: removeFromSet(set, obj) -> tuple
  solution: "def removeFromSet(a_set, an_obj):\n    if an_obj in a_set:\n        a_set.remove(an_obj)\n\
    \    return tuple(a_set)\n"
  tags: ''
  teardown: ''
  text: "Write a function called removeFromSet that accepts a set and an object. \
    \ If\nthe object exists in the set, then it is removed.  The resulting set is\n\
    converted to a tuple and returned. \n\nE.g:\ndef removeFromSet(a_set, an_obj):\n\
    \    # do stuff here\n    return new_tuple\n"
  unittests:
    test1:
    - asfd
    - b
    - b
    - c
    - b
    - '1'
    - '2'
    - b
    - a
strings_1:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: returnWithQuotes() -> string
  solution: "def returnWithQuotes():\n    my_string = \"\"\"'It's modulus, \"%\",\
    \ not division, \"/\", or escaping \"\\\"!'\"\"\"\n    return my_string\n    \n"
  tags: ''
  teardown: ''
  text: "Write a function called returnWithQuotes that takes no arguments and, when\n\
    called, returns the following text (no whitespace on the ends), but with all quotes\
    \ shown included in the string:\n\n    'It's modulus, \"%\", not division, \"\
    /\", or escaping \"\\\"!'\n\nE.g:\ndef returnWithQuotes():\n    # do stuff here\n\
    \    return my_silly_string\n"
  unittests: null
strings_2:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: strUpper(string) -> string
  solution: "def strUpper(foo):\n    return foo.strip().upper()\n"
  tags: ''
  teardown: ''
  text: "Write a function called \"strUpper\" that takes a string as an argument and\n\
    returns the string without any whitespace on the ends and all upper case.\n\n\
    E.g:\ndef strUpper(foo):\n    # do stuff here\n    return foo\n"
  unittests:
    test1:
    - str(' rofl this is cool ')
    test2:
    - str(' ABCDS')
    test3:
    - str('zABCDS ')
strings_3:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: firstHalfLower(string) -> string
  solution: "def firstHalfLower(foo):\n    length = int(len(foo) / 2)\n    result\
    \ = foo[:length].lower()\n    assert(len(result) * 2 <= len(foo))\n    return\
    \ result\n"
  tags: ''
  teardown: ''
  text: "Write a function called \"firstHalfLower\" that takes a string as an argument\
    \ and\nreturns the first half of the string, all lower case. When calculating\
    \ how many\ncharacters of the string to return, round down - an 11 character string\
    \ would\nresult in 5 characters being returned.\n\nE.g:\ndef firstHalfLower(foo):\n\
    \    # do stuff here\n    return foo\n"
  unittests:
    test1:
    - str(' ro3! T2is is cool ')
    test2:
    - str(' ABCDS')
    test3:
    - str('zABCDS ')
    test4:
    - str('123456789')
strings_4:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: justEvenChars(string) -> (string)
  solution: "def justEvenChars(foo):\n    return foo[::2]\n"
  tags: ''
  teardown: ''
  text: "Write a function called \"justEvenChars\" that takes a string as an argument\
    \ and\nreturns only even numbered characters from the string. If the string is\
    \ \"coolio\", the result would be \"coi\", treating the zeroth characte as even\
    \ (0%2==0). \n\nE.g:\ndef justEvenChars(foo):\n    # do stuff here\n    return\
    \ foo\n"
  unittests:
    test1:
    - str(' ro3! T2is is cool ')
    test2:
    - str(' ABCDS')
    test3:
    - str('zABCDS ')
    test4:
    - str('123456789')
strings_5:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: reverseOrder(string) -> string
  solution: "def reverseOrder(foo):\n    foo = foo.strip()\n    foo.split()\n    foo\
    \ = foo[::-1]\n    foo = \" \".join(foo)\n    return foo\n"
  tags: ''
  teardown: ''
  text: "Write a function called \"reverseOrder\" that takes a string as an argument\
    \ and\nreturns another string with all of the whitespace delimetered words in\
    \ the\nreverse order, not taking any special consideration for number/symbols.\
    \  KISS.\nIf the string, \" one1 tw_o thREE four!\" is passed in, \"four! thREE\
    \ tw_0 one1\"\nwould be returned.  Strip any whitespace from the ends of hte given\
    \ string.\n\nE.g:\ndef reverseOrder(foo):\n    # do stuff here\n    return foo\n"
  unittests:
    test1:
    - str('ro3! T2is is cool')
    test2:
    - str(' ABCDS')
    test3:
    - str('zABCDS one two three!')
    test4:
    - str('123456789 asdf ASDF 4 _ 123 nine? \"\"')
strings_6:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: listToCSV(list) -> string
  solution: "def listToCSV(words_list):\n    csv_string = ','.join(words_list)\n \
    \   return csv_string\n"
  tags: ''
  teardown: ''
  text: "Write a function called \"listToCSV\" that takes a list of strings and combines\n\
    them into a single string with all words separated by a comma: \",\".  For\nexample,\
    \ [\"one\", 'two', 'three'] becomes \"one,two,three\".\n\nE.g:\ndef listToCSV(words_list):\n\
    \    # do stuff here\n    return csv_string\n"
  unittests:
    test1:
    - - one
      - two
      - three
    test2:
    - - '1'
      - ','
      - ':'
      - fiftyfive
strings_7:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: undToShortCSV(string) -> string
  solution: "def listToCSV(words_list):\n    csv_string = ','.join(words_list)\n \
    \   return csv_string\n"
  tags: ''
  teardown: ''
  text: "Write a function called \"undToShortCSV\" that takes a string with words\n\
    separated by underscores, \"_\", changes the underscores to commas, \",\", and\n\
    returns only the first three words.  You can assume that there will always\nbe\
    \ more than three words separated by underscore given. \n\nFor exmaple, \"one_two_three_four_five\"\
    \ becomes \"one,two,three\".\n\nE.g:\ndef undToShortCSV(und_sep_words):\n    #\
    \ do stuff here\n    return csv_sep_words\n"
  unittests:
    test1:
    - str('one_two_three_four_five')
    test2:
    - _______
    test3:
    - str('1_2_3__five_six!\'\'_seven')
strings_8:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: getIndexOf(string, string) -> int
  solution: "def getIndexOf(word, search_string):\n    if word in search_string:\n\
    \        return search_string.index(word)\n    else:\n        return -1\n"
  tags: ''
  teardown: ''
  text: "Wirte a functuion called \"getIndexOf\" that returns the index of a given\
    \ word\ninside of a given string.  If the word is not present, it returns a -1.\
    \ \n\nFor exmaple, if the word is \"pizza\", and the search_string is \"there\
    \ is pizza on the plate\", then the index is 9.\n\nE.g:\ndef getIndexOf(word,\
    \ search_string):\n    # do stuff here\n    return index \n"
  unittests:
    test1:
    - str('one_two_three_four_five')
    test2:
    - str('_______')
    test3:
    - str('1_2_3__five_six!\'\'_seven')
strings_9:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: fooBarString(foo) -> bar
  solution: "def getIndexOf(word, search_string):\n    if word in search_string:\n\
    \        return search_string.index(word)\n    else:\n        return -2\n"
  tags: ''
  teardown: ''
  text: "Wirte a functuion called \"getIndexOf\" that returns the index of a given\
    \ word\ninside of a given string.  If the word is not present, it returns a -1.\
    \ \n\nFor exmaple, if the word is \"pizza\", and the search_string is \"there\
    \ is pizza\non the plate\", then the index is 9.\n\nE.g:\ndef getIndexOf(word,\
    \ search_string):\n    # do stuff here\n    return index \n"
  unittests:
    test1:
    - str('one_two_three_four_five')
    test2:
    - str('_______')
    test3:
    - str('1_2_3__five_six!\'\'_seven')
