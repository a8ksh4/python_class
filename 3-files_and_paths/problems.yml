os_basics_1:
  history: {}
  imports: ''
  posttest: ''
  pretest: ''
  ratings:
    challenging: 0
    interesting: 0
    useful: 0
  setup: ''
  signature: moveAFile(src_path, dst_path)
  solution: "def moveAFile(src_path, dst_path):\n    import shutils\n    shutils.move(src_path,\
    \ dst_path)\n"
  successes: 1
  tags:
  - sample
  - arithmatic
  teardown: "import random\nimport string\nimport os\nf0 = './{}'.format(''.join(random.choices(string.ascii_uppercase,\
    \ k=10)))\nf1 = './{}'.format(''.join(random.choices(string.ascii_uppercase, k=10)))\n\
    open(f0, 'w').write('asdf\\n123')\n\ntry:\n    moveAFile(f0, f1)\nexcept:\n  \
    \  pass\n\nif os.path.isfile(f1):\n    self.test_results.append('pass')\nelse:\n\
    \    self.test_results.append('failed to copy file to dst')\n\nif not os.path.isfile(f0):\n\
    \    self.test_results.append('pass')\nelse: \n    self.test_results.append('failed\
    \ to rm src file')\n\nif ( self.test_result[0] == 'pass'\n       and open(f1,\
    \ 'r').read() == 'asdf\\n123' ):\n    self.test_results.append('pass')\nelse:\n\
    \    self.test_results.append('failed preserver file contents')\n"
  text: "Write a function called moveAFile that accepts a source file path and a dest\
    \ file path and\nmoves the file to the destination.  \n\nE.g.\ndef moveAFile(src_path,\
    \ dst_path):\n    #your code here\n    #return nothing\n"
  tier: 30
  unittests: skip
os_basics_2:
  history: {}
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  ratings:
    challenging: 0
    interesting: 0
    useful: 0
  setup: seed({seed})
  signature: cdAndWrite(dir_path, file_name, content) -> file_size
  solution: "def cdAndWrite(dir_path, file_name, content):\n    import os\n    os.chdir(dir_path)\n\
    \    open(file_name, 'w').write(content)\n    return os.stat(file_name).st_size\n"
  successes: 1
  tags:
  - sample
  - arithmatic
  teardown: ''
  text: "Write a function called cdAndWrite that changes directory to the given path,\
    \ then edits a file\nand writes the given content to it. Return the size of the\
    \ file in bytes! \n\nE.g.\ndef cdAndWrite(dir_path, file_name, content):\n   \
    \ #your code here\n    return file_size\n"
  tier: 35
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(-3)
    - int(0)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
os_basics_3:
  history: {}
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  ratings:
    challenging: 0
    interesting: 0
    useful: 0
  setup: seed({seed})
  signature: listDirFilter(dir_path, regex_filter)
  solution: "def listDirFilter(dir_path, regex_filter):\n    import re\n    out =\
    \ []\n    for name in os.listdir(dir_path):\n        if re.match(regex_filter,\
    \ name):\n            out.append(name)\n    return out\n\n"
  successes: 1
  tags:
  - sample
  - arithmatic
  teardown: ''
  text: "Write a function called listDirFilter that accepts a directory path and a\
    \ regex filter.  It\nretuns a list of files at the directory path whos names match\
    \ the given regex.  Return only\nthe file names, not their complete path. \n\n\
    E.g.\ndef listDirFilter(dir_path, regex_filter):\n    #your code here\n    return\
    \ files_list\n"
  tier: 35
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(-3)
    - int(0)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
os_basics_4:
  history: {}
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  ratings:
    challenging: 0
    interesting: 0
    useful: 0
  setup: seed({seed})
  signature: createTmpDir(dir_name) -> dir_path
  solution: "def createTmpDir(dir_name):\n    os.umask(0077)\n    dir_path = '/tmp/{}'.format(dir_name)\n\
    \    os.mkdir(dir_path)\n    return dir_path\n"
  successes: 1
  tags:
  - sample
  - arithmatic
  teardown: ''
  text: "Write a function called createTmpDir that accepts a directory name and creates\
    \ it in /tmp.\nSet the permissions so that only the directory owner can read/write/execute\
    \ it. Return the\ncomplete path to the directory.  Bonus: Can you do this in a\
    \ way that avoids a race condition\nsecurity vulnerability? \n\nE.g.\ndef createTmpDir(dir_name):\n\
    \    #your code here\n    return dir_path\n"
  tier: 35
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(-3)
    - int(0)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
os_basics_5:
  history: {}
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  ratings:
    challenging: 0
    interesting: 0
    useful: 0
  setup: seed({seed})
  signature: realPath(path)
  solution: "def realPath(dir_name):\n    return os.path.realpath(dir_name)\n"
  successes: 1
  tags:
  - sample
  - arithmatic
  teardown: ''
  text: "Write a function called realPath that accepts a path, checks if it has any\
    \ symlinks in it,\nand returns the actual path (wihout symlinks) to the file or\
    \ directory the original path\npointed to. \n\nE.g.\ndef realPath(dir_name):\n\
    \    # your code here\n    return real_path\n"
  tier: 31
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(-3)
    - int(0)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
os_basics_6:
  history: {}
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  ratings:
    challenging: 0
    interesting: 0
    useful: 0
  setup: seed({seed})
  signature: filePaths(dir_path, files_list) -> file_paths list
  solution: "def filePaths(dir_path, files_list):\n    out = []\n    for fname in\
    \ files_list:\n        fpath = os.path.realpath(os.path.join(dir_path, fname))\n\
    \        out.append(fpath)\n    return out\n"
  successes: 1
  tags:
  - sample
  - arithmatic
  teardown: ''
  text: "Write a function called filePaths that accepts a directory path and a list\
    \ of files. It\nreturns a list of full paths to those files. \n\nFor example,\
    \ if dir_path is '/tmp/' and files list is ['./foobar.txt', 'diddun.txt'], the\
    \ output would be ['/tmp/foobar.txt', '/tmp/diddun.txt'].\n\nE.g.\ndef filePaths(dir_path,\
    \ files_list):\n    # your code here\n    return files_paths\n"
  tier: 34
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(-3)
    - int(0)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
readwrite_1:
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  ratings:
    challenging: 0
    interesting: 0
    useful: 0
  setup: seed({seed})
  signature: readFileToString(path) -> string
  solution: "def readFileToString(path):\n    with open(path, 'r') as f:\n       \
    \ contents = f.read()\n    return contents\n"
  successes: 1
  tags:
  - sample
  - arithmatic
  teardown: ''
  text: "Write a function called readFileToString that accepts a path, opens the path,\n\
    and returns the contents of the file as a string value. You can assume that \n\
    you'll have access to the file, it won't be binary data, you don't need to do\n\
    anything to the given path to open it.  \n\nE.g.\ndef readFileToString(path_to_file):\n\
    \    #your code here\n    return contents\n"
  tier: 30
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(-3)
    - int(0)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
readwrite_2:
  history: {}
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  ratings:
    challenging: 0
    interesting: 0
    useful: 0
  setup: seed({seed})
  signature: readLiensFromFile(path) -> list of strings
  solution: "def readLinesFromFile(path):\n    with open(path, 'r') as f:\n      \
    \  contents = f.readlines()\n    return contents\n"
  successes: 1
  tags:
  - sample
  - arithmatic
  teardown: ''
  text: "Write a function called readLinesFromFiles that accepts a path, reads the\
    \ contents, and\nreturns a list of stings for each line in the file. \n\nE.g.\n\
    def readLinesFromFile(path_to_file):\n    #your code here\n    return contents\n"
  tier: 30
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(-3)
    - int(0)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
readwrite_3:
  history: {}
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  ratings:
    challenging: 0
    interesting: 0
    useful: 0
  setup: seed({seed})
  signature: appendLineToFile(path, string)
  solution: "def appendLineToFile(path, content):\n    with open(path, 'a') as f:\n\
    \        f.write(content)\n"
  successes: 1
  tags:
  - sample
  - arithmatic
  teardown: ''
  text: "Write a function called appendLineToFile that accepts a path and a string,\
    \ and writes the\nstring to the end of the file (without modifying the existing\
    \ contents in the file).\n\nE.g.\ndef appendLineToFile(path, content):\n    #your\
    \ code here\n    #return nothing\n"
  tier: 30
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(-3)
    - int(0)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
readwrite_4:
  history: {}
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  ratings:
    challenging: 0
    interesting: 0
    useful: 0
  setup: seed({seed})
  signature: truncateWriteFile(path, content)
  solution: "def truncateWriteFile(path, content):\n    with open(path, 'w') as f:\n\
    \        f.write(content)\n"
  successes: 1
  tags:
  - sample
  - arithmatic
  teardown: ''
  text: "Write a function called truncateWriteFile that accepts a path and a string,\
    \ and writes the\nstring to the file, truncating (overwriting) any existing content\
    \ in the file. \n\nE.g.\ndef truncateWriteFile(path, content):\n    #your code\
    \ here\n    #return nothing\n"
  tier: 30
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(-3)
    - int(0)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
readwrite_5:
  history: {}
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  ratings:
    challenging: 0
    interesting: 0
    useful: 0
  setup: seed({seed})
  signature: rewriteInLower(source_path, dest_path)
  solution: "def rewriteInLower(source_path, dest_path):\n    contents = open(source_path,\
    \ 'r').read().lower()\n    open(dest_path, 'w').write(contents)\n"
  successes: 1
  tags:
  - sample
  - arithmatic
  teardown: ''
  text: "Write a function called rewriteInLower that accepts a source and destination\
    \ path.  It reads\nin the source path, converts the contents to all lower case,\
    \ and writes them to the\ndestination path. \n\nE.g.\ndef rewriteInLower(source_path,\
    \ dest_path):\n    #your code here\n    #return nothing\n"
  tier: 31
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(-3)
    - int(0)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
