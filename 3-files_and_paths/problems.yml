os_basics_1:
  imports: 'import shutil

    import random

    import string

    import os'
  posttest: ''
  pretest: ''
  seed: 0
  setup: ''
  signature: moveAFile(src_path, dst_path)
  solution: "\ndef moveAFile(src_path, dst_path):\n    shutil.move(src_path, dst_path)\n"
  tags:
  - sample
  - arithmatic
  teardown: "\nf0 = './{{}}'.format(''.join(random.choices(string.ascii_uppercase,\
    \ k=10)))\nf1 = './{{}}'.format(''.join(random.choices(string.ascii_uppercase,\
    \ k=10)))\nopen(f0, 'w').write('asdf\\n123')\n\n#try:\nmoveAFile(f0, f1)\n#except\
    \ Exception as e:\n#    print(\"Exception: {{}}\".format(e))\n\nprint(\"SRC:\"\
    , f0)\nprint(\"DST:\", f1)\n\nif os.path.isfile(f1):\n    self.test_results.append('pass')\n\
    else:\n    self.test_results.append('failed to copy file to dst')\n\nif not os.path.isfile(f0):\n\
    \    self.test_results.append('pass')\nelse: \n    self.test_results.append('failed\
    \ to rm src file')\n\nif ( self.test_results[0] == 'pass'\n        and open(f1,\
    \ 'r').read() == 'asdf\\n123' ):\n    self.test_results.append('pass')\nelse:\n\
    \    self.test_results.append('failed preserver file contents')\n\n#cleanup\n\
    if os.path.isfile(f0):\n    os.remove(f0)\nif os.path.isfile(f1):\n    os.remove(f0)\n"
  text: "Write a function called moveAFile that accepts a source file path and a dest\
    \ file path and\nmoves the file to the destination.  \n\nE.g.\ndef moveAFile(src_path,\
    \ dst_path):\n    #your code here\n    #return nothing\n"
  tier: 30
  unittests: skip
os_basics_1b:
  imports: 'import shutil

    import random

    import string

    import os'
  posttest: ''
  pretest: ''
  setup: 'f0 = ''./{{}}''.format(''''.join(random.choices(string.ascii_uppercase,
    k=10)))

    f1 = ''./{{}}''.format(''''.join(random.choices(string.ascii_uppercase, k=10)))

    open(f0, ''w'').write(''asdf\n123'')

    '
  signature: moveAFile(src_path, dst_path)
  solution: "\ndef moveAFile(src_path, dst_path):\n    shutil.move(src_path, dst_path)\n"
  tags:
  - sample
  - arithmatic
  teardown: "\nf0 = './{{}}'.format(''.join(random.choices(string.ascii_uppercase,\
    \ k=10)))\nf1 = './{{}}'.format(''.join(random.choices(string.ascii_uppercase,\
    \ k=10)))\nopen(f0, 'w').write('asdf\\n123')\n\n#try:\nmoveAFile(f0, f1)\n#except\
    \ Exception as e:\n#    print(\"Exception: {{}}\".format(e))\n\nprint(\"SRC:\"\
    , f0)\nprint(\"DST:\", f1)\n\nif os.path.isfile(f1):\n    self.test_results.append('pass')\n\
    else:\n    self.test_results.append('failed to copy file to dst')\n\nif not os.path.isfile(f0):\n\
    \    self.test_results.append('pass')\nelse: \n    self.test_results.append('failed\
    \ to rm src file')\n\nif ( self.test_results[0] == 'pass'\n        and open(f1,\
    \ 'r').read() == 'asdf\\n123' ):\n    self.test_results.append('pass')\nelse:\n\
    \    self.test_results.append('failed preserver file contents')\n\n#cleanup\n\
    if os.path.isfile(f0):\n    os.remove(f0)\nif os.path.isfile(f1):\n    os.remove(f0)\n"
  text: "Write a function called moveAFile that accepts a source file path and a dest\
    \ file path and\nmoves the file to the destination.  \n\nE.g.\ndef moveAFile(src_path,\
    \ dst_path):\n    #your code here\n    #return nothing\n"
  unittests: skip
os_basics_2:
  imports: ''
  posttest: ''
  pretest: ''
  setup: ''
  signature: cdAndWrite(dir_path, file_name, content) -> file_size
  solution: "\ndef cdAndWrite(dir_path, file_name, content):\n    import os\n    os.chdir(dir_path)\n\
    \    open(file_name, 'w').write(content)\n    return os.stat(file_name).st_size\n"
  tags:
  - sample
  - arithmatic
  teardown: "\nimport random\nimport string\nimport os\ncwd = os.getcwd()\nd0 = ''.join(random.choices(string.ascii_uppercase,\
    \ k=10))\np0 = './{{}}'.format(d0)\nf0 = './{{}}'.format(''.join(random.choices(string.ascii_uppercase,\
    \ k=10)))\ncontent = 'asdf\\n123\\nfoobar\\n\\n'\nos.mkdir(d0)\n\ntry:\n    cdAndWrite(d0,\
    \ f0, content)\nexcept:\n    pass\n\nif os.getcwd().endswith(d0):\n    self.test_results.append('pass')\n\
    else:\n    self.test_results.append('failed cd to given directory')\n\nif ( self.test_result[0]\
    \ == 'pass'\n\t    and if os.path.isfile(f0) ):\n    self.test_results.append('pass')\n\
    else:\n    self.test_results.append('failed to write file...')\n\nif ( self.test_result[0]\
    \ == 'pass'\n\t\tand self.test_result[1] == 'pass' \n        and open(f0, 'r').read()\
    \ == content ):\n    self.test_results.append('pass')\nelse:\n    self.test_results.append('failed\
    \ preserver file contents')\n\n# cleanup\nif os.path.isfile(f0):\n\tos.remove(f0)\n\
    os.chdir(cwd)\nif os.path.isdir(p0):\n    os.rmdir(p0)\n"
  text: "Write a function called cdAndWrite that changes directory to the given path,\
    \ then edits a file\nand writes the given content to it. Return the size of the\
    \ file in bytes! \n\nE.g.\ndef cdAndWrite(dir_path, file_name, content):\n   \
    \ #your code here\n    return file_size\n"
  tier: 35
  unittests: skip
os_basics_3:
  imports: import random\nimport string\nimport os\nimport re\n
  posttest: ''
  pretest: ''
  seed: 0
  setup: ''
  signature: listDirFilter(dir_path, regex_filter)
  solution: "\ndef listDirFilter(dir_path, regex_filter):\n    import re\n    out\
    \ = []\n    for name in os.listdir(dir_path):\n        if re.match(regex_filter,\
    \ name):\n            out.append(name)\n    return out\n\n"
  tags:
  - sample
  - arithmatic
  teardown: "\nimport random\nimport string\nimport os\nimport re\ne0 = ''.join(random.choices(string.ascii_uppercase,\
    \ k=4))\ne1 = ''.join(random.choices(string.ascii_uppercase, k=4))\nfor e in (e0,\
    \ e1):\n    for n in range(5):\n        f = \"{{}}.{{}}\".format(n, e)\n     \
    \   open(f, 'w')\nreg_filter = '(./){0,1}[0-9].' + e0\ntry:\n    out = listDirFilter('./',\
    \ reg_filter)\nexcept:\n    out = []\n\nif len(out) == 5:\n    self.test_results.append('pass')\n\
    else:\n    self.test_results.append('failed wrong num files returned')\n\nif len(set(out))\
    \ == 5:\n    self.test_results.append('pass')\nelse:\n    self.test_results.append('failed\
    \ duplicate files returned')\n\nself.test_results.append('failed wrong files returned')\n\
    for f in out:\n    if not re.match(reg_filter, f):\n        break\nelse:\n   \
    \ self.test_results[-1] = 'pass'\n\nfor e in (e0, e1):\n    for n in range(5):\n\
    \        f = \"{{}}.{{}}\".format(n, e)\n        if os.path.exists(f):\n     \
    \       os.remove(f)\n\n"
  text: "Write a function called listDirFilter that accepts a directory path and a\n\
    regex filter.  It retuns a list of files at the directory path whos names\nmatch\
    \ the given regex.  Return only the file names, not their complete path. \n\n\
    E.g.\ndef listDirFilter(dir_path, regex_filter):\n    #your code here\n    return\
    \ files_list\n"
  tier: 35
  unittests: skip
os_basics_4:
  imports: import random\nimport string\nimport os\nimport re\n
  posttest: ''
  pretest: ''
  seed: 0
  setup: ''
  signature: createTmpDir(dir_name) -> dir_path
  solution: "\ndef createTmpDir(dir_name):\n    #os.umask(0077)\n    dir_path = '/tmp/{}'.format(dir_name)\n\
    \    print('creating dir: {}'.format(dir_path))\n    os.mkdir(dir_path)\n    return\
    \ dir_path\n"
  tags:
  - sample
  - arithmatic
  teardown: "\nimport random\nimport string\nimport os\nimport re\nd0 = ''.join(random.choices(string.ascii_uppercase,\
    \ k=4))\np0 = '/tmp/{{}}'.format(d0)\n\ntry:\n    out = createTmpDir(d0)\nexcept:\n\
    \    out = ''\n\nprint('p0:', p0)\nif out.strip() == p0:\n    self.test_results.append('pass')\n\
    else:\n    self.test_results.append('failed return path was not /tmp/<dirname>')\n\
    \nif os.path.isdir(p0):\n    self.test_results.append('pass')\n    os.rmdir(p0)\n\
    else:\n    self.test_results.append('failed tmp directory was not created')\n\n"
  text: "Write a function called createTmpDir that accepts a directory name and\n\
    creates it in /tmp.  Set the permissions so that only the directory owner\ncan\
    \ read/write/execute it. Return the complete path to the directory.  \n\nBonus:\
    \ Can you do this in a way that avoids a race condition security\nvulnerability?\
    \ \n\nE.g.\ndef createTmpDir(dir_name):\n    #your code here\n    return dir_path\n"
  tier: 35
  unittests: skip
os_basics_5:
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  setup: seed({seed})
  signature: realPath(path)
  solution: "\ndef realPath(dir_name):\n    return os.path.realpath(dir_name)\n"
  tags:
  - sample
  - arithmatic
  teardown: '

    '
  text: "Write a function called realPath that accepts a path, checks if it has any\
    \ symlinks in it,\nand returns the actual path (wihout symlinks) to the file or\
    \ directory the original path\npointed to. \n\nE.g.\ndef realPath(dir_name):\n\
    \    # your code here\n    return real_path\n"
  tier: 31
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(-3)
    - int(0)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
os_basics_6:
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  setup: seed({seed})
  signature: filePaths(dir_path, files_list) -> file_paths list
  solution: "\ndef filePaths(dir_path, files_list):\n    out = []\n    for fname in\
    \ files_list:\n        fpath = os.path.realpath(os.path.join(dir_path, fname))\n\
    \        out.append(fpath)\n    return out\n"
  tags:
  - sample
  - arithmatic
  teardown: ''
  text: "Write a function called filePaths that accepts a directory path and a list\
    \ of files. It\nreturns a list of full paths to those files. \n\nFor example,\
    \ if dir_path is '/tmp/' and files list is ['./foobar.txt', 'diddun.txt'], the\
    \ output would be ['/tmp/foobar.txt', '/tmp/diddun.txt'].\n\nE.g.\ndef filePaths(dir_path,\
    \ files_list):\n    # your code here\n    return files_paths\n"
  tier: 34
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(-3)
    - int(0)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
readwrite_1:
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  setup: seed({seed})
  signature: readFileToString(path) -> string
  solution: "\ndef readFileToString(path):\n    with open(path, 'r') as f:\n     \
    \   contents = f.read()\n    return contents\n"
  tags:
  - sample
  - arithmatic
  teardown: '

    '
  text: "Write a function called readFileToString that accepts a path, opens the path,\n\
    and returns the contents of the file as a string value. You can assume that \n\
    you'll have access to the file, it won't be binary data, you don't need to do\n\
    anything to the given path to open it.  \n\nE.g.\ndef readFileToString(path_to_file):\n\
    \    #your code here\n    return contents\n"
  tier: 30
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(-3)
    - int(0)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
readwrite_2:
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  setup: seed({seed})
  signature: readLiensFromFile(path) -> list of strings
  solution: "\ndef readLinesFromFile(path):\n    with open(path, 'r') as f:\n    \
    \    contents = f.readlines()\n    return contents\n"
  tags:
  - sample
  - arithmatic
  teardown: ''
  text: "Write a function called readLinesFromFiles that accepts a path, reads the\
    \ contents, and\nreturns a list of stings for each line in the file. \n\nE.g.\n\
    def readLinesFromFile(path_to_file):\n    #your code here\n    return contents\n"
  tier: 30
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(-3)
    - int(0)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
readwrite_3:
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  setup: seed({seed})
  signature: appendLineToFile(path, string)
  solution: "\ndef appendLineToFile(path, content):\n    with open(path, 'a') as f:\n\
    \        f.write(content)\n"
  tags:
  - sample
  - arithmatic
  teardown: ''
  text: "Write a function called appendLineToFile that accepts a path and a string,\
    \ and writes the\nstring to the end of the file (without modifying the existing\
    \ contents in the file).\n\nE.g.\ndef appendLineToFile(path, content):\n    #your\
    \ code here\n    #return nothing\n"
  tier: 30
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(-3)
    - int(0)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
readwrite_4:
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  setup: seed({seed})
  signature: truncateWriteFile(path, content)
  solution: "\ndef truncateWriteFile(path, content):\n    with open(path, 'w') as\
    \ f:\n        f.write(content)\n"
  tags:
  - sample
  - arithmatic
  teardown: ''
  text: "Write a function called truncateWriteFile that accepts a path and a string,\
    \ and writes the\nstring to the file, truncating (overwriting) any existing content\
    \ in the file. \n\nE.g.\ndef truncateWriteFile(path, content):\n    #your code\
    \ here\n    #return nothing\n"
  tier: 30
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(-3)
    - int(0)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
readwrite_5:
  imports: from random import randint, seed
  posttest: ''
  pretest: ''
  setup: seed({seed})
  signature: rewriteInLower(source_path, dest_path)
  solution: "def rewriteInLower(source_path, dest_path):\n    contents = open(source_path,\
    \ 'r').read().lower()\n    open(dest_path, 'w').write(contents)\n"
  tags:
  - sample
  - arithmatic
  teardown: ''
  text: "Write a function called rewriteInLower that accepts a source and destination\
    \ path.  It reads\nin the source path, converts the contents to all lower case,\
    \ and writes them to the\ndestination path. \n\nE.g.\ndef rewriteInLower(source_path,\
    \ dest_path):\n    #your code here\n    #return nothing\n"
  tier: 31
  unittests:
    test1:
    - int(3)
    - int(5)
    test2:
    - int(-3)
    - int(0)
    test3:
    - randint(-100,100)
    - randint(-100,100)
    test4_x4:
    - randint(-1000,1000)
    - randint(-1,1)
